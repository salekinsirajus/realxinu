/*  main_pi.c  - main */

#include <xinu.h>
#include <stdlib.h>


syscall sync_printf(char *fmt, ...)
{
        intmask mask = disable();
        void *arg = __builtin_apply_args();
        __builtin_apply((void*)kprintf, arg, 100);
        restore(mask);
        return OK;
}

uint32 get_timestamp(){
    return ctr1000;
}

void run_for_ms(uint32 time){
    uint32 start = proctab[currpid].runtime;
    while (proctab[currpid].runtime-start < time);
}

void highprio_process(pi_lock_t *mutex){
    struct procent *prptr;
    prptr = &proctab[currpid];
	print_queue(mutex->waiting, "highp beg mutex_waiting_queue");
    sleepms(2000); //just to make sure there is enough time before he wakes up

    pi_lock(mutex);
    run_for_ms(2000);
    pi_unlock(mutex);

	print_queue(mutex->waiting, "highp end mutex_waiting_queue");
    kprintf("process %d [high priority] finished running at %d ms.\n", currpid, get_timestamp());
    kprintf("total_runtime for process %d: %d\n", currpid, prptr->runtime);
    return;
}

void midprio_process(pi_lock_t *mutex1){
    struct procent *prptr;
    prptr = &proctab[currpid];
	print_queue(mutex->waiting, "midp beg mutex_waiting_queue");
	sleepms(200);
    pi_lock(mutex);
    //run forever
    run_for_ms(1000);
    pi_unlock(mutex);
	print_queue(mutex->waiting, "midp end mutex_waiting_queue");
    
    kprintf("process %d [mid priority] finished running at %d ms.\n", currpid, get_timestamp());
    kprintf("total_runtime for process %d: %d\n", currpid, prptr->runtime);
    return;
}

void lowprio_process(pi_lock_t *mutex){
    struct procent *prptr;
    prptr = &proctab[currpid];
	print_queue(mutex->waiting, "lowp beg mutex_waiting_queue");
    pi_lock(mutex);
    //run forever
    run_for_ms(2000);
    pi_unlock(mutex);
	print_queue(mutex->waiting, "lowp end mutex_waiting_queue");
    
    kprintf("process %d [low priority] finished running at %d ms.\n", currpid, get_timestamp());
    kprintf("total_runtime for process %d: %d\n", currpid, prptr->runtime);
    return;
}

process main(void){
    //create highprio_process, high prirority
    //create lowprio_process, low priority
    //the idea is to let B hog the lock with critical section
    //so that A does not get a change to run
    
	pi_lock_t mutex;
	pi_initlock(&mutex);

    pid32 high_pid = create((void *)highprio_process, INITSTK, 20,"highp", 1, &mutex);
    pid32 mid_pid = create((void *)midprio_process, INITSTK, 19,"midp", 1, &mutex);
    pid32 low_pid = create((void *)lowprio_process, INITSTK, 18,"lowp", 1, &mutex);

    resume(high_pid);
    resume(mid_pid);
    resume(low_pid);


	kprintf("pid[priority]: low %d:[5], mid %d:[10], high %d:[15]\n", low_pid, mid_pid, high_pid);
	struct procent *prptr;
	prptr = &proctab[high_pid];
	kprintf("pr_state for high_priority: %d\n", prptr->prstate);

    receive();
    receive();
    receive();

    sync_printf("TEST PASSED!\n");

    return OK;
}
